

## Техническое задание

Нам необходимо разработать интернет-ресурс для фанатского сервера одной известной MMORPG — что-то вроде доски объявлений. 

- [ ] Пользователи нашего ресурса должны иметь возможность зарегистрироваться в нём по e-mail, получив письмо с кодом подтверждения регистрации. 
- [ ] После регистрации им становится доступно создание и редактирование объявлений.
- [ ] Объявления состоят из заголовка и текста, внутри которого могут быть картинки, встроенные видео и другой контент. 
- [ ] Пользователи могут отправлять отклики на объявления других пользователей, состоящие из простого текста. 
- [ ] При отправке отклика пользователь должен получить e-mail с оповещением о нём. 
- [ ] Также пользователю должна быть доступна приватная страница с откликами на его объявления, внутри которой он может фильтровать отклики по объявлениям, удалять их и принимать (при принятии отклика пользователю, оставившему отклик, также должно прийти уведомление). 
- [ ] Кроме того, пользователь обязательно должен определить объявление в одну из следующих категорий: Танки, Хилы, ДД, Торговцы, Гилдмастеры, Квестгиверы, Кузнецы, Кожевники, Зельевары, Мастера заклинаний.
- [ ] Также мы бы хотели иметь возможность отправлять пользователям новостные рассылки.

## План

### Модели
```mermaid
	A[Пост]
    B[Пользователь] --> A[Пост]
    C[Комментарий] -->|отправитель, получатель| B[Пользователь]
```

Способ приложить картинки:
https://djangopackages.org/grids/g/wysiwyg/

### Представления (view)

Urls:
- /сomments - доступно пользователю
- /posts - доступно всем
- /post{id}/ - доступно всем
- /post {id}/comment доступно залогиненному пользователю
 
### Аутентификация
```python
def usual_login_view(request)
	username = request.POST['username']
	password = request.POST['password']
	user = authentificate(request, username-username, password=password)
	if user is not None:
	OneTimeCode.objects.create(code=random.choie('abcde'), user=user)
		# send one-time code to e-mail
		# redirect somewhere
	else:
		#Return an 'invalid login' error message.
		...

def login_with_code_view(request)
	username = request.POST['username']
	code = request.POST['code']
	if OneTimeCode.objects.filter(code=code, user__username-ysername).exists():
		login(request, user)
	else:
		# error
 
```
Допустим, у нас есть модель  _Post_  (объявление), связанная с моделью  _User_  через  _ForeignKey_-поле  `author`, и модель  _Reply_  (отклик), связанная с моделью  _Post_  через  _ForeignKey_-поле  `post`. Как нам наиболее эффективно получить все отклики пользователя  _user_?
```python
Reply.objects.filter(post__author=user)
```

А как с теми же моделями, что и в предыдущем вопросе, наиболее эффективно отфильтровать _Queryset_ откликов _replies_ по объявлению `post`?
```python
replies.filter(post=post)
```
Как избежать «проблемы N+1» — ситуации, в которой нам необходимо для каждого объекта из какого-то  _Queryset_’а запросить  _Queryset_  связанных объектов?
``` python
Воспользоваться методами `prefetch_related` и `select_related`
```

Как наиболее эффективно проверить существование конкретного объекта модели?
```python
Воспользоваться методом `.exists()`
```
Как можно защититься от некорректных данных в полях модели?
```
- Использовать валидаторы
- Проверять вводимые данные внутри представления
- Определять методы  `.validate()`  на формах
```
### Сигналы как триггеры отправки писем
```mermaid
['reply created' signal] --> [email]  <--- 'profile changed' signal
[login]
```

Django-silk 
Django Debug Tollbar